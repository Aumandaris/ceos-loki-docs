<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Mejores prácticas para etiquetas en Loki :: Documentación de Loki</title>
    <link rel="canonical" href="https://aumandaris.github.io/ceos-loki-docs/ceos-loki-docs/2.2.1/index.html/ceos-loki-docs/2.2.1/mejores-practicas/mejores-practicas.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://aumandaris.github.io/ceos-loki-docs/ceos-loki-docs/2.2.1/index.html">
        <img src="/docs/ceos-loki-docs/2.2.1/_images/logo.png" width="100">
        <span>| Documentación de Loki<span>     
      </a>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ceos-loki-docs" data-version="2.2.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Documentación de Loki</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../descripcion-general/descripcion-general.html">Descripción general</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../instalacion/instalacion.html">Instalación</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../instalacion/construir-desde-la-fuente.html">Construir desde la luente</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../instalacion/local.html">Local</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../comenzando/comenzando.html">Comenzando</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../comenzando/introducir-registros-en-loki.html">Introducir registros en Loki</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../comenzando/etiquetas.html">Etiquetas</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../comenzando/logcli.html">LogCLI</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../comenzando/loki-en-grafana.html">Loki en Grafana</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../comenzando/solucion-de-problemas.html">Solución de problemas</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="mejores-practicas.html">Mejores prácticas</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Documentación de Loki</span>
    <span class="version">2.2.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Documentación de Loki</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">2.2.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Documentación de Loki</a></li>
    <li><a href="mejores-practicas.html">Mejores prácticas</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/Aumandaris/ceos-loki-docs/edit/master/modules/ROOT/pages/mejores-practicas/mejores-practicas.adoc">Editar esta página</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Mejores prácticas para etiquetas en Loki</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Loki está en desarrollo activo y trabajamos constantemente para mejorar el rendimiento. Pero estas son algunas de las mejores prácticas más actuales para etiquetas que le brindarán la mejor experiencia con Loki.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_las_etiquetas_estáticas_son_buenas"><a class="anchor" href="#_las_etiquetas_estáticas_son_buenas"></a>Las etiquetas estáticas son buenas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cosas como host, aplicación y entorno son excelentes etiquetas. Serán limitados para un sistema/aplicación dado y tendrán valores limitados. Use etiquetas estáticas para facilitar la consulta de sus registros en un sentido lógico (por ejemplo, muéstreme todos los registros para una aplicación determinada y un entorno específico, o muéstreme todos los registros para todas las aplicaciones en un host específico).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_utilizar_etiquetas_dinámicas_con_moderación"><a class="anchor" href="#_utilizar_etiquetas_dinámicas_con_moderación"></a>Utilizar etiquetas dinámicas con moderación</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Demasiadas combinaciones de valores de etiquetas dan lugar a demasiados flujos. Las sanciones por eso en Loki son un índice grande y pequeñas porciones en el almacén, lo que a su vez puede reducir el rendimiento.</p>
</div>
<div class="paragraph">
<p>Para evitar esos problemas, no agregue una etiqueta a algo hasta que sepa que lo necesita. Utilice expresiones de filtro ( |= “text”, |~ “regex”, …) y aplique fuerza bruta a esos registros. Funciona y es rápido.</p>
</div>
<div class="paragraph">
<p>Desde el principio, hemos establecido una etiqueta dinámicamente utilizando fuentes de información Promtail para <code>level</code>. Esto nos pareció intuitivo, ya que a menudo solo queríamos mostrar registros para <code>level=”error”</code>; sin embargo, estamos reevaluando esto ahora como si escribiera una consulta. <code>{app=”loki”} |= “level=error”</code> está demostrando ser tan rápido para muchas de nuestras aplicaciones como <code>{app=”loki”,level=”error”}</code>.</p>
</div>
<div class="paragraph">
<p>Esto puede parecer sorprendente, pero si las aplicaciones tienen un volumen medio a bajo, esa etiqueta hace que los registros de una aplicación se dividan en hasta cinco flujos, lo que significa que se almacenan 5 veces más fragmentos. Y la carga de fragmentos tiene una sobrecarga asociada. Imagínese ahora si esa consulta fuera <code>{app=”loki”,level!=”debug”}</code>. Eso tendrá que cargar <strong>muchos</strong> más fragmentos que <code>{app=”loki”} != “level=debug”</code>.</p>
</div>
<div class="paragraph">
<p>Anteriormente, mencionamos no agregar etiquetas hasta que las <em>necesitara</em>, entonces, ¿cuándo <em>necesitaría</em> etiquetas? Un poco más abajo hay una sección sobre <code>chunk_target_size</code>. Si establece esto en 1MB (lo cual es razonable), esto intentará cortar fragmentos con un tamaño comprimido de 1MB, que es aproximadamente 5MB de registros sin comprimir (puede ser hasta 10MB según la compresión). Si sus registros tienen suficiente volumen para escribir 5MB en menos tiempo que <code>max_chunk_age</code>, o <strong>muchos</strong> fragmentos en ese período de tiempo, es posible que desee considerar dividirlos en flujos separados con una etiqueta dinámica.</p>
</div>
<div class="paragraph">
<p>Lo que desea evitar es dividir un archivo de registro en flujos, lo que da como resultado que los fragmentos se vacíen porque el flujo está inactivo o alcanza la edad máxima antes de llenarse. A partir de <a href="https://grafana.com/blog/2020/04/01/loki-v1.4.0-released-with-query-statistics-and-up-to-300x-regex-optimization/">Loki 1.4.0</a>, hay una métrica que puede ayudarlo a comprender por qué los fragmentos se vacían <code>sum by (reason) (rate(loki_ingester_chunks_flushed_total{cluster="dev"}[1m]))</code>.</p>
</div>
<div class="paragraph">
<p>No es fundamental que todos los fragmentos estén llenos cuando se vacían, pero mejorará muchos aspectos de la operación. Como tal, nuestra guía actual aquí es evitar las etiquetas dinámicas tanto como sea posible y, en cambio, favorecer las expresiones de filtro. Por ejemplo, no agregue una etiqueta dinámica <code>level</code>, simplemente <code>|= “level=debug”</code> en su lugar.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_los_valores_de_las_etiquetas_siempre_deben_estar_limitados"><a class="anchor" href="#_los_valores_de_las_etiquetas_siempre_deben_estar_limitados"></a>Los valores de las etiquetas siempre deben estar limitados</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Si está configurando etiquetas dinámicamente, nunca use una etiqueta que pueda tener valores ilimitados o infinitos. Esto siempre resultará en grandes problemas para Loki.</p>
</div>
<div class="paragraph">
<p>Trate de mantener los valores delimitados a un conjunto lo más pequeño posible. No tenemos una guía perfecta sobre lo que puede manejar Loki, pero piense en dígitos de un solo dígito, o tal vez decenas de valores para una etiqueta dinámica. Esto es menos crítico para las etiquetas estáticas. Por ejemplo, si tiene 1000 hosts en su entorno, estará bien tener una etiqueta de host con 1000 valores.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tenga_en_cuenta_las_etiquetas_dinámicas_aplicadas_por_los_clientes"><a class="anchor" href="#_tenga_en_cuenta_las_etiquetas_dinámicas_aplicadas_por_los_clientes"></a>Tenga en cuenta las etiquetas dinámicas aplicadas por los clientes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Loki tiene varias opciones de cliente: <a href="https://github.com/grafana/loki/tree/master/docs/sources/clients/promtail">Promtail</a> (que también admite la ingestión de diarios de systemd y la ingesta de syslog basada en TCP), <a href="https://github.com/grafana/loki/tree/master/fluentd/fluent-plugin-grafana-loki">Fluentd</a>, <a href="https://github.com/grafana/loki/tree/master/cmd/fluent-bit">Fluent Bit</a>, un <a href="https://grafana.com/blog/2019/07/15/lokis-path-to-ga-docker-logging-driver-plugin-support-for-systemd/">complemento de Docker</a> y más.</p>
</div>
<div class="paragraph">
<p>Cada uno de estos viene con formas de configurar qué etiquetas se aplican para crear flujos de registro. Pero tenga en cuenta qué etiquetas dinámicas se pueden aplicar. Use la API de la serie Loki para tener una idea de cómo se ven sus flujos de registro y ver si puede utilizar formas de reducir los flujos y la cardinalidad. La información de la serie se puede consultar a través de la <a href="#api/api.adoc#series" class="page unresolved">API de la Serie</a>, o puede utilizar <a href="../comenzando/logcli.html" class="page">logcli</a>.</p>
</div>
<div class="paragraph">
<p>En Loki 1.6.0 y posteriores, el comando de la serie logcli agregó el indicador <code>--analyze-labels</code> específicamente para depurar etiquetas de alta cardinalidad:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Total Streams:  25017
Unique Labels:  8

Label Name  Unique Values  Found In Streams
requestId   24653          24979
logStream   1194           25016
logGroup    140            25016
accountId   13             25016
logger      1              25017
source      1              25016
transport   1              25017
format      1              25017</pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, puede ver que la etiqueta <code>requestId</code> tenía 24653 valores diferentes de 24979 secuencias en las que se encontró, ¡esto es malo!</p>
</div>
<div class="paragraph">
<p>Este es un ejemplo perfecto de algo que no debería ser una etiqueta, <code>requestId</code> debería eliminarse como una etiqueta y, en su lugar, deberían usarse expresiones de filtro para consultar registros para un <code>requestId</code> específico. Por ejemplo, si <code>requestId</code> se encuentra en la línea de registro como un par clave=valor, puede escribir una consulta como esta: <code>{logGroup="group1"} |= "requestId=32422355"</code></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configurar_el_almacenamiento_en_caché"><a class="anchor" href="#_configurar_el_almacenamiento_en_caché"></a>Configurar el almacenamiento en caché</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Loki puede almacenar datos en caché en muchos niveles, lo que puede mejorar drásticamente el rendimiento. Los detalles de esto estarán en una publicación futura.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_los_registros_deben_estar_en_orden_de_tiempo_creciente_por_flujo"><a class="anchor" href="#_los_registros_deben_estar_en_orden_de_tiempo_creciente_por_flujo"></a>Los registros deben estar en orden de tiempo creciente por flujo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Un problema que muchas personas tienen con Loki es que su cliente recibe errores por entradas de registro fuera de orden. Esto sucede debido a esta regla estricta y rápida dentro de Loki:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Para cualquier flujo de registro único, los registros siempre deben enviarse en orden de tiempo creciente. Si se recibe un registro con una marca de tiempo más antigua que el registro más reciente recibido para ese flujo, ese registro se eliminará.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hay algunas cosas para analizar de esa declaración. La primera es que esta restricción es por flujo. Veamos un ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{job=”syslog”} 00:00:00 i’m a syslog!
{job=”syslog”} 00:00:01 i’m a syslog!</pre>
</div>
</div>
<div class="paragraph">
<p>Si Loki recibiera estas dos líneas que son para el mismo flujo, todo estaría bien. Pero, ¿qué pasa con este caso?</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{job=”syslog”} 00:00:00 i’m a syslog!
{job=”syslog”} 00:00:02 i’m a syslog!
{job=”syslog”} 00:00:01 i’m a syslog!  &lt;- Rejected out of order!</pre>
</div>
</div>
<div class="paragraph">
<p>¿Qué podemos hacer al respecto? ¿Y si esto se debiera a que las fuentes de estos registros eran sistemas diferentes? Podemos resolver esto con una etiqueta adicional que es única por sistema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{job=”syslog”, instance=”host1”} 00:00:00 i’m a syslog!
{job=”syslog”, instance=”host1”} 00:00:02 i’m a syslog!
{job=”syslog”, instance=”host2”} 00:00:01 i’m a syslog!  &lt;- Accepted, this is a new stream!
{job=”syslog”, instance=”host1”} 00:00:03 i’m a syslog!  &lt;- Accepted, still in order for stream 1
{job=”syslog”, instance=”host2”} 00:00:02 i’m a syslog!  &lt;- Accepted, still in order for stream 2</pre>
</div>
</div>
<div class="paragraph">
<p>Pero, ¿qué pasa si la propia aplicación genera registros que no funcionan? Bueno, me temo que esto es un problema. Si extrae la marca de tiempo de la línea de registro con algo como <a href="#clientes/promtail/etapas/marca-de-tiempo.adoc" class="page unresolved">la etapa de fuente de información de promtail</a>, usted podría <em>no hacer</em> esto y dejar que Promtail asigne una marca de tiempo a las líneas de registro. O con suerte, puede solucionarlo en la propia aplicación.</p>
</div>
<div class="paragraph">
<p>¡Pero quiero que Loki arregle esto! ¿Por qué no puedes almacenar en búfer los flujos y reordenarlos por mí? Para ser honesto, porque esto agregaría mucha sobrecarga de memoria y complicación a Loki, y como ha sido un hilo común en esta publicación, queremos que Loki sea simple y rentable. Idealmente, querríamos mejorar a nuestros clientes para que realicen un almacenamiento y una clasificación básicos, ya que este parece un mejor lugar para resolver este problema.</p>
</div>
<div class="paragraph">
<p>También vale la pena señalar que la naturaleza de procesamiento por lotes de la <em>API push</em> de Loki puede llevar a que se reciban algunos casos de errores fuera de orden, que en realidad son falsos positivos. (Quizás un lote tuvo éxito parcialmente y estuvo presente; o cualquier cosa que haya tenido éxito anteriormente devolvería una entrada fuera de orden; o se aceptaría algo nuevo).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_utilizar_chunk_target_size"><a class="anchor" href="#_utilizar_chunk_target_size"></a>Utilizar <code>chunk_target_size</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esto se agregó anteriormente en la versión de <a href="https://grafana.com/blog/2020/01/22/loki-1.3.0-released/">Loki v1.3.0</a> y hemos estado experimentando con ello durante varios meses. Tenemos <code>chunk_target_size: 1536000</code> en todos nuestros entornos ahora. Esto le indica a Loki que intente llenar todos los fragmentos hasta un tamaño <em>comprimido</em> objetivo de 1,5MB. Estos fragmentos más grandes son más eficientes para que Loki los procese.</p>
</div>
<div class="paragraph">
<p>Un par de otras variables de configuración afectan la capacidad de un fragmento. Loki tiene un <code>max_chunk_age</code> predeterminado de 1h y <code>chunk_idle_period</code> de 30m para limitar la cantidad de memoria utilizada, así como la exposición de registros perdidos si el proceso falla.</p>
</div>
<div class="paragraph">
<p>Dependiendo de la compresión utilizada (hemos estado usando snappy, que tiene menos compresibilidad pero un rendimiento más rápido), necesita 5-10x o 7,5-10MB de datos de registro sin procesar para llenar un fragmento de 1,5MB. Recordando que un fragmento es por flujo, en cuantos más flujos divida sus archivos de registro, más fragmentos se quedarán en la memoria y mayor será la probabilidad de que se vacíen al alcanzar uno de los tiempos de espera mencionados anteriormente antes de que se llenen.</p>
</div>
<div class="paragraph">
<p>Muchos fragmentos pequeños sin relleno son actualmente kriptonita para Loki. Siempre estamos trabajando para mejorar esto y podemos considerar un compactador para mejorarlo en algunas situaciones. Pero, en general, la guía debería ser la misma: ¡haga todo lo posible para llenar los fragmentos!</p>
</div>
<div class="paragraph">
<p>Si tiene una aplicación que puede registrar lo suficientemente rápido como para llenar estos fragmentos rápidamente (mucho menos que <code>max_chunk_age</code>), entonces es más razonable usar etiquetas dinámicas para dividirlo en flujos separados.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_utilizar_print_config_stderr_o_log_config_reverse_order"><a class="anchor" href="#_utilizar_print_config_stderr_o_log_config_reverse_order"></a>Utilizar <code>-print-config-stderr</code> o <code>-log-config-reverse-order</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A partir de la versión 1.6.0, Loki y Promtail tienen indicadores que volcarán todo el objeto de configuración en stderr, o el archivo de registro, cuando se inicien.</p>
</div>
<div class="paragraph">
<p><code>-print-config-stderr</code> es bueno cuando se ejecuta loki directamente, p. ej. <code>./loki</code>, ya que puede obtener una salida rápida de toda la configuración de Loki.</p>
</div>
<div class="paragraph">
<p><code>-log-config-reverse-order</code> es el indicador con el que ejecutamos Loki en todos nuestros entornos, las entradas de configuración se invierten para que el orden de las configuraciones se lea correctamente de arriba a abajo cuando se ve en Explorar en Grafana.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>Esta página fue hecha usando la interfaz predeterminada de Antora.</p>
  <p>El código de esta interfaz está licenciado bajo los términos de la licencia MPL-2.0.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
